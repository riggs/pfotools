# -*- coding: utf-8 -*-

from django.core.urlresolvers import reverse
from django.utils.encoding import iri_to_uri
from django.db.models.base import ModelBase

from pprint import pprint

from ..utils import public, Logging_Dict


def dict_logger(prefix=''):
    def func(*args, **kwargs):
        pprint("Building %s" % prefix)
        d = Logging_Dict(*args, **kwargs)
        d.prefix = prefix
        pprint("Built %s" % prefix)
        pprint(d)
        return d
    return func


@public
class publish:
    """
    Decorator to record Models to be published via rest API.

    :param *args: Names of fields to be exposed.
    :param path: URL path component in API, uses lowercase Model name if not given.
    :param **kwargs: API_display_name='name_of_field' or callable to return dereferenced data.
    :return: Wrapped function, unchanged.
    """
    for_publication = {}

    def __init__(self, *args, path=None, **kwargs):
        self.args = args
        self.path = path
        self.kwargs = kwargs
        assert 'name' in kwargs, "'name' field required"
        assert 'url' in kwargs, "'url' field required"

    def __call__(self, Model):
        attrs = {'path': self.path.lower() if self.path is not None else Model.__name__.lower()}
        for arg in self.args:
            attrs[arg] = arg
        attrs.update(self.kwargs)
        self.for_publication[Model] = attrs
        return Model


@public
def generate_tree(Models):
    """
    Takes in dictionary generated by public decorator, generates hierarchical tree to be used to create URLs.

    :param Models:
    :return:
    """

    def build_tree(Model, attrs, parent):
        # Get called recursively to create current node based on Model & attrs.
        # Then adds that node to appropriate parent node.
        # Not a separate function because of dependency on Models.
        attrs = attrs.copy()
        for m in Model.mro()[1:]:   # Iterate over superclasses
            a = Models.get(m)       # <- Dependency on Models
            if a is not None:       # Current Model is subclass of another entry in Models, nest paths appropriately
                parent = build_tree(m, a, parent)
                break

        path = attrs.pop('path', None)
        if path in parent and parent[path]['Model'] is not Model:
            raise ValueError("Conflicting paths for {}, {}".format(Model, parent[path]['Model']))
        default_node = {'Model': Model, 'fields': attrs}
        #default_node = dict_logger("%s: " % str(Model))(default_node)
        node = parent.setdefault(path, default_node)
        return node

    # {'path1': {'Model': Model1, 'fields': ['name', 'plus']},
    #  'path2': {'Model': Model2, 'fields': ['name']},
    #  'path3': {'Model': Model3, 'fields': [],
    #            'path3_1': {'Model': Model3_1, 'fields': [...]},
    #            'path3_2': {'Model': Model3_2, 'fields': [...]},
    #           },
    # }
    directory_tree = {}
    #directory_tree = dict_logger('root: ')(directory_tree)

    for Model, attrs in Models.items():
        build_tree(Model, attrs, parent=directory_tree)

    return directory_tree


@public
def get_entry_url(obj, request, namespaces):
    if isinstance(obj, ModelBase):
        entry_name = ''
        namespace = ':'.join(namespaces[obj] + ('index',))
    else:
        entry_name = str(obj)
        namespace = ':'.join(namespaces[type(obj)] + ('index',))
    return request.build_absolute_uri(reverse(namespace, current_app=request.resolver_match.namespace)
                                      + iri_to_uri(entry_name))


@public
def name_and_url(obj, request, namespaces):
    return {'name': str(obj), 'url': get_entry_url(obj, request, namespaces)}

